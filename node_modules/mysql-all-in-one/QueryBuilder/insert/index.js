"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const utils_1 = require("../utils");
const types_2 = require("./types");
const buildRow = (keys, insertRow) => {
    const sqlValues = [];
    const insertValues = keys.reduce((acc, cur) => {
        acc[cur] = insertRow[cur];
        return acc;
    }, {});
    return {
        statement: `(${Object.values(insertValues)
            .map((v) => {
            if ((0, types_1.isSqlExpressionPreparedStatement)(v)) {
                v = (0, utils_1.placeAliasInSqlExpression)(v, null);
                sqlValues.push(...v.values);
                return (0, utils_1.putBrackets)(v.statement);
            }
            sqlValues.push(v);
            return "?";
        })
            .join(",")})`,
        values: sqlValues,
        __is_prep_statement: true,
    };
};
const buildInsertRows = (rows, columns) => {
    if ((0, types_2.isInsertRows)(rows)) {
        const keys = (0, types_1.isArrayOfStrings)(columns)
            ? columns
            : Array.isArray(rows)
                ? Object.keys(rows[0])
                : Object.keys(rows);
        const prepStatement = Array.isArray(rows)
            ? rows
                .map((insertRow) => buildRow(keys, insertRow))
                .reduce((acc, cur) => {
                acc.statement.push(cur.statement);
                acc.values.push(...cur.values);
                return acc;
            }, { statement: [], values: [] })
            : buildRow(keys, rows);
        if (Array.isArray(prepStatement.statement))
            prepStatement.statement = prepStatement.statement.join(",");
        return {
            statement: prepStatement.statement,
            values: prepStatement.values,
            __is_prep_statement: true,
        };
    }
    throw `Invalid rows format for insert object, insert rows must be one or many objects with valid SQL values String | Date | null | boolean | number (undefined is also accepted, but ignored); Insert row object received: ${rows}`;
};
const buildColumns = (rows, columns) => {
    if (!(0, types_2.isInsertRows)(rows))
        return "";
    return `(${((0, types_1.isArrayOfStrings)(columns)
        ? columns
        : Array.isArray(rows)
            ? Object.keys(rows[0])
            : Object.keys(rows))
        .map(utils_1.putBackticks)
        .join(",")})`;
};
/**
 *
 * @param table Table to insert
 * @param rows An array of Objects or a single object (keys are the column names)
 * @param opts Extra insert options like `ignore`
 * @returns INSERT INTO SQL Query
 * @example insert('table', [{id:1, name: "John"}, {id:2, name: "Anne"}], {ignore:true});
 * >>> "INSERT IGNORE INTO `table` (`id`,`name`) VALUES (1,'John'),(2,'Anne');"
 */
const insert = (table, rows, opts) => {
    const { ignore, columns, returnPreparedStatement } = Object.assign(Object.assign({}, types_2.defaultInsertOptions), opts);
    const insertRowsPrepStatement = buildInsertRows(rows, columns);
    const values = insertRowsPrepStatement.values;
    const statement = `INSERT ${ignore === true ? "IGNORE " : ""}INTO ${(0, utils_1.putBackticks)(table)} ${buildColumns(rows, columns)} VALUES ${insertRowsPrepStatement.statement};`;
    const prepStatement = {
        statement,
        values,
        __is_prep_statement: true,
    };
    return returnPreparedStatement === true
        ? prepStatement
        : (0, types_1.generateQueryFromPreparedStatement)(prepStatement);
};
exports.default = insert;
