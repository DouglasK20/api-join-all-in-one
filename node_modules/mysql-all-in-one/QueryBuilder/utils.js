"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.placeAliasInSqlExpression = exports.sqlExp = exports.sqlCol = exports.isNotEmptyString = exports.safeApplyAlias = exports.extractTableAlias = exports.putBrackets = exports.putBackticks = exports.escapeNames = exports.escStr = exports.sqlExpression = exports.escVal = void 0;
const mysql2_1 = __importDefault(require("mysql2"));
const types_1 = require("./types");
/**
 * Escapes a value into a valid mysql String representation
 */
exports.escVal = mysql2_1.default.escape;
/**
 *
 * @description Tagged template literal function to create sql expressions, will automatically escape interpolated variables to valid sql values or if will escape column names if combined with `sqlCol` function, or to complete ignore a string use `sqlExp` function;
 * @example sqlExpression`STR_TO_DATE(${sqlCol('date')}, "%d/%m/%Y") = ${new Date(2020, 8, 30)} AND ${sqlCol('date') > ${sqlCol('another_table.date')`
 * >> 'STR_TO_DATE(date, "%d/%m/%Y") = "2020-8-30" AND date > '
 */
const sqlExpression = ([firstStr, ...rest], ...values) => {
    const prepValues = [];
    const statement = rest.reduce((acc, cur, i) => {
        const curVal = values[i];
        if (curVal instanceof types_1.SqlExp) {
            return `${acc}${curVal.expression}${cur}`;
        }
        if (curVal instanceof types_1.SqlColumn) {
            return `${acc}${(0, exports.safeApplyAlias)((0, exports.escapeNames)(curVal.column), "__SQL__EXPRESSION__ALIAS__")}${cur}`;
        }
        if ((0, types_1.isSqlExpressionPreparedStatement)(curVal)) {
            prepValues.push(...curVal.values);
            return `${acc}${curVal.statement}${cur}`;
        }
        prepValues.push(curVal);
        return `${acc}?${cur}`;
    }, firstStr);
    return {
        statement,
        values: prepValues,
        __is_prep_statement: true,
    };
};
exports.sqlExpression = sqlExpression;
/**
 * @description Tagged template literal function to escape all passed values
 * @example const name = 'Foo'; escStr`name=${name}`;
 * >> "name = 'Foo'"
 */
const escStr = ([firstStr, ...rest], ...values) => rest.reduce((acc, cur, i) => `${acc}${(0, exports.escVal)(values[i])}${cur}`, firstStr);
exports.escStr = escStr;
const escapeNames = (key) => key
    .trim()
    .replace(/ +/g, " ") // removes double spaces
    .replace(/ as /i, " ") // remove " as " not case sensitive
    .split(" ")
    .map((val) => val
    .split(".")
    .map((v) => (0, exports.putBackticks)(v))
    .join("."))
    .join(" ");
exports.escapeNames = escapeNames;
const putBackticks = (value) => value.charAt(0) === "`" && value.charAt(value.length - 1) === "`"
    ? value
    : `\`${value}\``;
exports.putBackticks = putBackticks;
const putBrackets = (value) => `(${value})`;
exports.putBrackets = putBrackets;
/**
 *
 * @param tableRef
 * @returns [table, alias]
 */
const extractTableAlias = (tableRef) => {
    const split = tableRef.split(" ");
    if (split.length !== 2)
        return [tableRef, tableRef];
    return [split[0], split[1]];
};
exports.extractTableAlias = extractTableAlias;
const safeApplyAlias = (subject, alias) => subject.indexOf(".") === -1 && alias && typeof alias === "string"
    ? `${alias}.${subject}`
    : subject;
exports.safeApplyAlias = safeApplyAlias;
const isNotEmptyString = (val) => val !== undefined &&
    val !== null &&
    typeof val === "string" &&
    val.length !== 0;
exports.isNotEmptyString = isNotEmptyString;
/**
 *
 * @description Will return SqlColumn object, that is interpretated as a column, not as a string. Can be used in WHERE, sqlExpression
 * @example
 * {where: {date: sqlCol('another_table.date')}}
 * >> WHERE `date` = `another_table`.`date`
 */
const sqlCol = (column) => new types_1.SqlColumn(column);
exports.sqlCol = sqlCol;
const sqlExp = (column) => new types_1.SqlExp(column);
exports.sqlExp = sqlExp;
const placeAliasInSqlExpression = (sqlExpression, alias) => {
    sqlExpression.statement = sqlExpression.statement
        .split('__SQL__EXPRESSION__ALIAS__.')
        .join(typeof alias === 'string' && alias.length !== 0 ? `${alias}.` : '');
    return sqlExpression;
};
exports.placeAliasInSqlExpression = placeAliasInSqlExpression;
