"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.statementsMerge = exports.arrayUnflat = exports.group = void 0;
const types_1 = require("../QueryBuilder/types");
const lodash_1 = __importDefault(require("lodash"));
const types_2 = require("./types");
const group = (data, by, columnGroups) => {
    return data.reduce((acc, cur) => {
        if (!(0, types_2.isColumnGroups)(columnGroups))
            throw 'Invalid Column Groups, must be an Array of strings or Object with only string values.';
        let index = acc.findIndex((v) => v[by] === cur[by]);
        if (index === -1) {
            const newRow = Object.assign({}, cur);
            Object.entries(columnGroups).forEach(([groupName, groupColumns]) => {
                const newColumnNames = (0, types_1.isArrayOfStrings)(groupColumns)
                    ? groupColumns
                    : Object.values(groupColumns);
                newRow[groupName] = [];
                newColumnNames.forEach((col) => delete newRow[col]);
            });
            acc.push(newRow);
            index = acc.length - 1;
        }
        Object.entries(columnGroups).forEach(([groupName, groupColumns]) => {
            const groupObject = {};
            if ((0, types_1.isArrayOfStrings)(groupColumns)) {
                groupColumns.forEach((col) => {
                    groupObject[col] = cur[col];
                });
            }
            else {
                Object.entries(groupColumns).forEach(([newColumn, oldColumn]) => {
                    groupObject[newColumn] = cur[oldColumn];
                });
            }
            if (!Object.values(groupObject).every((v) => lodash_1.default.isNil(v)) &&
                acc[index][groupName].findIndex((v) => lodash_1.default.isEqual(v, groupObject)) === -1) {
                acc[index][groupName].push(groupObject);
            }
        });
        return acc;
    }, []);
};
exports.group = group;
const arrayUnflat = (array, size) => {
    if (!size || size <= 0 || !Array.isArray(array))
        return array;
    const newArray = [];
    while (array.length > 0)
        newArray.push(array.splice(0, size));
    return newArray;
};
exports.arrayUnflat = arrayUnflat;
const statementsMerge = (stringArray, maxStringSize) => {
    return stringArray.reduce((acc, cur) => {
        cur = `${cur};`;
        if (acc[acc.length - 1] !== undefined &&
            acc[acc.length - 1].length + cur.length <= maxStringSize) {
            acc[acc.length - 1] = `${acc[acc.length - 1]}${cur}`;
            return acc;
        }
        acc.push(cur);
        return acc;
    }, []);
};
exports.statementsMerge = statementsMerge;
