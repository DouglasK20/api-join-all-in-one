import { PoolOptions, Pool, PoolConnection } from "mysql2";
import { SelectOptions } from "../QueryBuilder/select/types";
import { PreparedStatement, SqlValues } from "../QueryBuilder/types";
import { DataPacket, DataSelectOptions, InsertOptionsDAO, DataAccessObjectOptions, GetPoolConnectionCallback, GetPoolConnectionOptions, DatabaseSelected, UpsertRow, UpsertOptions, Transaction } from "./types";
import { ConditionOptions } from "../QueryBuilder/select/conditionals/types";
import { DeleteOptions } from "../QueryBuilder/delete/types";
import { UpdateOptions, UpdateValues } from "../QueryBuilder/update/types";
import { InsertOptions, InsertRows } from "../QueryBuilder/insert/types";
/**
 * @description With a DataAccessObject instance is possible to execute commands, dump databases and load dumps (or any .sql file)
 * @param {PoolOptions} connectionData
 */
export declare class DataAccessObject {
    protected connectionData: PoolOptions;
    protected pool: Pool;
    protected options: DataAccessObjectOptions;
    protected executionMethod: Function;
    protected multipleStatementsPool: Pool;
    /**
     * @description With this instance is possible to execute commands (SELECT, INSERT, UPDATE, DELETE and any query in general), dump databases and load dumps (or any .sql file)
     * @param connectionData Information to create a connection. DataAccessObject uses a mysql2 pool behind the scenes, see: https://www.npmjs.com/package/mysql2#using-connection-pools.
     * @param options Extra options like `usePreparedStatements`
     * @example const dao = new DataAccessObject({
     * host: 'localhost',
     * user: 'root',
     * port: 3306,
     * password: '',
     * });
     */
    constructor(connectionData: PoolOptions, options?: DataAccessObjectOptions);
    /**
     * @description Creates a dump sql file.
     * @param database Database to dump
     * @param filePath File to output the dump (Won't create the folders if they don't exists).
     * @example dumpDatabase('mydatabase', './folder/mydatabase.sql');
     */
    dumpDatabase(database: string, filePath: string): Promise<void>;
    /**
     * @description Closes all connections. Node.js event loop will not be blocked by DAO anymore.
     */
    dispose(): Promise<void>;
    /**
     * @description Will drop and recreate a database.
     * @param database Database to empty
     * @example emptyDatabase('mydatabase');
     */
    emptyDatabase(database: string): Promise<void>;
    /**
     * @description Creates a new database from dump file (WARNING: if the database alredy exists it will be emptied).
     * @param database Database to be created or emptied
     * @param dumpFilePath Path to the dump file
     * @example loadDump('mydatabase', './folder/mydatabase.sql');
     */
    loadDump(database: string, dumpFilePath: string): Promise<void>;
    /**
     * @description Runs statements inside sql file on a specific database.
     * @param database Database selected during statements execution.
     * @param sqlFilePath Path to the sql file
     * @example loadSqlFile('mydatabase', './folder/mysqlstatements.sql');
     */
    loadSqlFile(database: string, sqlFilePath: string): Promise<void>;
    /**
     * @description Executes select command as a prepared statement and return its results.
     * @param selectOpts Select object structure.
     * @param opts Extra options about the command like `database`, `returnMode`, ...
     * @example select({
     * columns: ['id', 'foo', 'bar'],
     * from: 'table',
     * where: {id: 1},
     * }, {
     * database: 'foo',
     * });
     */
    select(selectOpts: SelectOptions, opts?: DataSelectOptions & DatabaseSelected): Promise<SqlValues | import("./types").RowDataPacket | DataPacket | SqlValues[]>;
    /**
     * @description Executes delete command as a prepared statement and return number of rows deleted.
     * @param table Table to delete from.
     * @param whereOpts Optional where object to filter delete.
     * @param opts Extra delete options like `ignore`, `quick`
     * @returns Number of deleted rows
     * @example delete('table', {id: 5}, {ignore: true});
     */
    delete(table: string, whereOpts?: ConditionOptions, opts?: DeleteOptions & DatabaseSelected, conn?: PoolConnection): Promise<number>;
    /**
     * @description Executes update command as a prepared statement and return the number of affected rows.
     * @param table Target table.
     * @param values Values to be updated (associative column: value).
     * @param whereOpts Optional where object to filter update.
     * @param opts Extra update options like `ignore`, `order`, `limit`
     * @returns Number of affected rows;
     * @example update('table', {name: 'foo', finished: 1}, {id: 3}, {ignore: true});
     */
    update(table: string, values: UpdateValues, whereOpts?: ConditionOptions, opts?: UpdateOptions & DatabaseSelected, conn?: PoolConnection): Promise<number>;
    /**
     * @description Will execute insert command as a prepared statement, by default will insert one row at a time, if you need to insert a large number of rows specify the option `rowsPerStatement` to insert more than one row per statement increassing performance.
     * @param table Target table to insert.
     * @param rows One or multiple rows to insert.
     * @param opts Extra insert options like `rowsPerStatement`, `ignore`, `columns`.
     * @returns Inserted ids (if);
     * @example insert('table', [{foo: 'bar1'}, {foo: 'bar2'}], {ignore: true});
     */
    insert(table: string, rows: InsertRows, opts?: InsertOptionsDAO & InsertOptions & DatabaseSelected, conn?: PoolConnection): Promise<number | number[] | null>;
    /**
     * @description Executes an update if the primary key column is defined in the row, executes an insert otherwise. (you can define the primary key column passing the name in the option `primaryKey`)
     * @param table Table to either update or insert
     * @param rows Row to either update or insert
     * @param opts Extra options like `primaryKey`
     * @returns One or many affected ids
     */
    upsert(table: string, rows: UpsertRow, opts?: UpsertOptions & DatabaseSelected, conn?: PoolConnection): Promise<number | number[] | null>;
    /**
     * @description Runs a query and return it's results, this command don't prepare and execute the statement.
     * @param sql Query to execute.
     * @param database Database selected during the query execution. If null will use default connection database passed on connectionData from DAO object.
     * @returns Query response.
     * @example query('SELECT * FROM `table`, 'mydatabase');
     */
    query(sql: string | PreparedStatement, database?: string, conn?: PoolConnection): Promise<unknown>;
    databaseExists(database: string): Promise<boolean>;
    /**
     * @description Creates a transaction, able to execute Insert, Update, Delete or even Upsert. When finished, the transaction can be commited, or in case of failure, it can be rollbacked.
     * @param database Database selected during the transaction.
     * @returns Transaction Object
     * @example const transaction = await dao.startTransaction();
    try {
        await transaction.insert("arquivo", {
            module: "1",
            moduleId: 123,
            keyS3: "/row
            ",
            name: "avc",
        });
        await transaction.insert("arquivo", {
            module: "2",
            moduleId: 123,
            keyS3: "/row",
            name: "avc",
        });
        await transaction.update(
            "arquivo",
            { keyS3: "UPDATED_S3" },
            { module: 2 }
        );

        await transaction.delete("arquivo", { module: 1 });
        await transaction.delete("unknow_table" , {
            module: 2,
        });

        await transaction.commit();
    } catch (err) {
        await transaction.rollback();
        throw err;
    }
     */
    startTransaction(database?: string): Promise<Transaction>;
    private execute;
    getPoolConnection(callback: GetPoolConnectionCallback, opts?: GetPoolConnectionOptions): Promise<unknown>;
    private connUseDatabase;
    private connUseDefaultDatabase;
    private connExecute;
    private connQuery;
    private getServerVariable;
    private connChangeUser;
}
